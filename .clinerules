# .clinerules for Sentinel Project

This file captures important patterns, preferences, and project intelligence to ensure consistent and effective development for the Sentinel platform.

## 1. Core Principles

- **Modularity:** All new features should be developed within the microservices-inspired architecture. Avoid adding unrelated functionality to existing services.
- **Agent Specialization:** When a new type of testing is required, the default approach should be to create a new, specialized agent rather than overloading an existing one.
- **Specification-Driven:** All development should be driven by the API specifications, both for the Sentinel platform's own internal APIs and for the APIs it is designed to test.
- **Hybrid AI:** Continue to leverage the hybrid approach of combining deterministic algorithms for rigor and LLMs for creativity and breadth.

## 2. Technology & Implementation Patterns

- **Python Backend:** All backend services will be written in Python 3.10+ using FastAPI.
- **Pydantic Models:** Use Pydantic for all data validation, settings management, and API request/response models. This ensures type safety and consistency.
- **Database Interaction:** Use an async ORM like `SQLAlchemy` with `asyncpg` for all interactions with the PostgreSQL database.
- **Dependency Injection:** Leverage FastAPI's dependency injection system for managing database sessions, service dependencies, and other resources.
- **Testing:** Use `pytest` for all backend unit and integration tests. The test suite for the platform itself should be comprehensive.

## 3. Agent Development Workflow

1.  **Define Specification:** Clearly define the agent's goal, inputs, and outputs in `agent-specifications.md`.
2.  **Develop Logic:** Implement the agent's core logic. If it involves interaction with `ruv-swarm`, ensure the commands are clearly defined.
3.  **Integrate with Orchestrator:** Add the new agent type to the Agent Orchestration Service's delegation logic.
4.  **Add to DB:** Ensure any new data generated by the agent is modeled correctly in the `database-schema.md` and corresponding ORM models.
5.  **Document:** Update all relevant Memory Bank files with the new agent's capabilities.

## 4. User Preferences & Workflow

- **CI/CD First:** The platform must be designed with CI/CD integration as a primary feature, not an afterthought. The API for triggering test runs should be stable and well-documented.
- **Actionable Feedback:** All user-facing outputs, from test results to linter reports, should provide clear, actionable feedback. Avoid vague error messages.
- **Transparency:** While the system is complex, its operations should be as transparent as possible. Logs should be detailed, and it should be clear why an agent made a particular decision.

## 5. RBAC Implementation Patterns

- **Authentication Service Architecture:** JWT-based authentication with bcrypt password hashing, role-based permissions, and in-memory user storage (easily replaceable with database)
- **Role Hierarchy:** Four-tier system (Admin > Manager > Tester > Viewer) with granular permissions for different platform features
- **Middleware Pattern:** Reusable authentication middleware with dependency injection for FastAPI services, supporting both required and optional authentication
- **Permission System:** Fine-grained permissions (e.g., "spec:create", "test_case:read") mapped to roles, enabling flexible access control
- **API Gateway Integration:** Centralized authentication through API Gateway with service-to-service token validation
- **Security Best Practices:** Secure token handling, password hashing, role-based endpoint protection, and comprehensive error handling

## 6. Advanced Analytics Implementation Patterns

- **Historical Trend Analysis**: Implement real database queries using SQLAlchemy with date-based aggregation, statistical calculations (mean, standard deviation), and gap-filling for missing dates
- **Anomaly Detection**: Use statistical methods (standard deviation thresholds) for identifying outliers in failure rates and latency patterns
- **Predictive Analytics**: Implement simple linear regression for trend prediction with confidence scoring based on slope magnitude
- **Quality Insights**: Generate automated insights by analyzing agent performance patterns and failure rate thresholds
- **Frontend Analytics**: Create tabbed analytics interfaces with responsive charts using Recharts library, supporting multiple time ranges and real-time data refresh
- **Database Performance**: Use PostgreSQL percentile functions for latency analysis and efficient date-based grouping for trend queries

## 7. Git Commit Guidelines

- **Concise Commit Messages**: Keep commit messages concise and under 50 characters for the title to avoid commit operation failures
- **Format**: Use format "Action: Brief description" (e.g., "Add: Analytics dashboard", "Fix: Database connection", "Update: Phase 4 completion")
- **Avoid Long Descriptions**: Detailed descriptions can cause git commit failures; keep them brief and focused
- **Use Present Tense**: Write commit messages in present tense (e.g., "Add feature" not "Added feature")

## 8. Configuration Modularization Patterns

**Configuration Management Approach:**
- **Centralized Configuration**: Use Pydantic BaseSettings for type-safe configuration management with environment variable support
- **Environment-Specific Files**: Separate configuration files for development, testing, production, and Docker environments
- **Security First**: Never commit sensitive data (passwords, API keys, secrets) to version control
- **Validation**: Configuration should fail fast with clear error messages on startup
- **Precedence Order**: Environment variables > configuration files > defaults
- **Backward Compatibility**: Maintain compatibility during configuration migration

**Configuration Categories:**
- **Database Settings**: Connection strings, pool configurations, migration settings
- **Service Discovery**: Inter-service URLs, ports, timeouts, health check intervals
- **Security Configuration**: JWT secrets, password policies, CORS settings, rate limiting
- **Network Settings**: Host bindings, port mappings, timeout configurations
- **Application Settings**: Feature flags, pagination limits, logging levels, agent parameters
- **External Services**: LLM API configurations, third-party service integrations

**Implementation Patterns Successfully Applied:**
- **Service Configuration Import**: All services now import configuration using `from config.settings import get_settings, get_service_settings, get_application_settings`
- **Timeout Centralization**: HTTP clients use `service_settings.service_timeout` instead of hardcoded values
- **Service URL Configuration**: All inter-service communication uses `service_settings.{service_name}_service_url`
- **Logging Configuration**: Services use `app_settings.log_level` and `app_settings.log_format` for consistent logging
- **Configuration Caching**: Use `@lru_cache()` decorator for performance optimization in configuration loading
- **Type Safety**: All configuration access is type-safe through Pydantic models with proper validation

## 9. Configuration Modularization Patterns (In Progress)

**Configuration Management Approach Successfully Implemented:**
- **Centralized Configuration**: Comprehensive Pydantic BaseSettings system with type-safe configuration management and environment variable support
- **Environment-Specific Files**: Separate configuration files for development, testing, production, and Docker environments with automatic loading
- **Security First**: Production-ready security validation with JWT secret key validation and environment-specific security settings
- **Validation**: Configuration fails fast with clear error messages on startup using Pydantic validators
- **Precedence Order**: Environment variables > configuration files > defaults with proper override handling
- **Backward Compatibility**: Maintained compatibility during configuration migration across all services

**Configuration Categories Successfully Implemented:**
- **Database Settings**: Connection strings, pool configurations (pool_size, max_overflow, pool_timeout, pool_recycle), migration settings
- **Service Discovery**: Inter-service URLs, ports, timeouts, health check intervals with centralized service communication
- **Security Configuration**: JWT secrets, password policies, CORS settings, rate limiting, admin user configuration
- **Network Settings**: Host bindings, port mappings, timeout configurations for all services
- **Application Settings**: Feature flags, pagination limits, logging levels, agent parameters, test execution settings
- **Frontend Configuration**: Separate JavaScript configuration system with environment detection and validation
- **Agent Configuration**: Data mocking settings, security testing parameters, performance testing configurations

**Implementation Patterns Successfully Applied:**
- **Service Configuration Import**: All services now import configuration using `from config.settings import get_settings, get_service_settings, get_application_settings`
- **Timeout Centralization**: HTTP clients use `service_settings.service_timeout` instead of hardcoded values across all services
- **Service URL Configuration**: All inter-service communication uses `service_settings.{service_name}_service_url`
- **Logging Configuration**: Services use `app_settings.log_level` and `app_settings.log_format` for consistent logging
- **Security Settings**: Auth service uses `security_settings.jwt_secret_key`, `security_settings.cors_origins`, etc.
- **Configuration Caching**: Use `@lru_cache()` decorator for performance optimization in configuration loading
- **Type Safety**: All configuration access is type-safe through Pydantic models with proper validation
- **Frontend Integration**: Created comprehensive frontend configuration system with environment-specific overrides and utility functions
- **Agent Configuration**: Agents use `getattr(app_settings, 'setting_name', default_value)` pattern for configuration access

**Services Successfully Updated:**
- **auth_service**: Complete security configuration integration with JWT, CORS, admin user, and logging settings
- **execution_service**: Service URLs, timeouts, and logging configuration centralized
- **orchestration_service**: Service URLs, timeouts, and logging configuration centralized
- **auth_middleware**: Service URLs and timeout configuration centralized
- **CLI**: Default base URL and timeout configuration using centralized settings
- **Frontend**: Complete configuration system with API URLs, timeouts, and environment-specific settings

**Agents Successfully Updated:**
- **data_mocking_agent**: Mock data generation settings, faker locale, response/parameter/entity variations
- **security_auth_agent**: BOLA vectors, authentication scenarios, security test timeouts, aggressive testing mode
- **performance_planner_agent**: Load test configurations, user limits, test duration, ramp-up times

## 10. Task Completion Protocol

**MANDATORY STEPS when completing any task:**

1. **Update Memory Bank**: Always update relevant memory bank files after completing a task:
   - Update `progress.md` to mark completed tasks and add implementation notes
   - Update `activeContext.md` to reflect current status and next steps
   - Update other relevant memory bank files if the task affects them

2. **Update README.md**: Always update the main README.md file to reflect:
   - New features or capabilities implemented
   - Changes to project structure or architecture
   - Updated phase completion status
   - New demo scripts or documentation

3. **Update .clinerules**: Document any new patterns, preferences, or implementation approaches discovered during the task

4. **Ask about GitHub Push**: At the end of every completed task, ask the user if all changes should be pushed to GitHub

## 7. Memory Bank Updates

-   The Memory Bank is the single source of truth. It MUST be updated after any significant architectural decision, feature implementation, or change in project direction.
-   `progress.md` should be updated at the end of every major work session to reflect the current state of the project.
-   `activeContext.md` should be reviewed and updated at the beginning of every work session to align on the immediate next steps.
