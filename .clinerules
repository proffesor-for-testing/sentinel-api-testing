# .clinerules for Sentinel Project

This file captures important patterns, preferences, and project intelligence to ensure consistent and effective development for the Sentinel platform.

## 1. Core Principles

- **Modularity:** All new features should be developed within the microservices-inspired architecture. Avoid adding unrelated functionality to existing services.
- **Agent Specialization:** When a new type of testing is required, the default approach should be to create a new, specialized agent rather than overloading an existing one.
- **Specification-Driven:** All development should be driven by the API specifications, both for the Sentinel platform's own internal APIs and for the APIs it is designed to test.
- **Hybrid AI:** Continue to leverage the hybrid approach of combining deterministic algorithms for rigor and LLMs for creativity and breadth.

## 2. Technology & Implementation Patterns

- **Python Backend:** All backend services will be written in Python 3.10+ using FastAPI.
- **Pydantic Models:** Use Pydantic for all data validation, settings management, and API request/response models. This ensures type safety and consistency.
- **Database Interaction:** Use an async ORM like `SQLAlchemy` with `asyncpg` for all interactions with the PostgreSQL database.
- **Dependency Injection:** Leverage FastAPI's dependency injection system for managing database sessions, service dependencies, and other resources.
- **Testing:** Use `pytest` for all backend unit and integration tests. The test suite for the platform itself should be comprehensive.

## 3. Agent Development Workflow

1.  **Define Specification:** Clearly define the agent's goal, inputs, and outputs in `agent-specifications.md`.
2.  **Develop Logic:** Implement the agent's core logic. If it involves interaction with `ruv-swarm`, ensure the commands are clearly defined.
3.  **Integrate with Orchestrator:** Add the new agent type to the Agent Orchestration Service's delegation logic.
4.  **Add to DB:** Ensure any new data generated by the agent is modeled correctly in the `database-schema.md` and corresponding ORM models.
5.  **Document:** Update all relevant Memory Bank files with the new agent's capabilities.

## 4. User Preferences & Workflow

- **CI/CD First:** The platform must be designed with CI/CD integration as a primary feature, not an afterthought. The API for triggering test runs should be stable and well-documented.
- **Actionable Feedback:** All user-facing outputs, from test results to linter reports, should provide clear, actionable feedback. Avoid vague error messages.
- **Transparency:** While the system is complex, its operations should be as transparent as possible. Logs should be detailed, and it should be clear why an agent made a particular decision.

## 5. RBAC Implementation Patterns

- **Authentication Service Architecture:** JWT-based authentication with bcrypt password hashing, role-based permissions, and in-memory user storage (easily replaceable with database)
- **Role Hierarchy:** Four-tier system (Admin > Manager > Tester > Viewer) with granular permissions for different platform features
- **Middleware Pattern:** Reusable authentication middleware with dependency injection for FastAPI services, supporting both required and optional authentication
- **Permission System:** Fine-grained permissions (e.g., "spec:create", "test_case:read") mapped to roles, enabling flexible access control
- **API Gateway Integration:** Centralized authentication through API Gateway with service-to-service token validation
- **Security Best Practices:** Secure token handling, password hashing, role-based endpoint protection, and comprehensive error handling

## 6. Advanced Analytics Implementation Patterns

- **Historical Trend Analysis**: Implement real database queries using SQLAlchemy with date-based aggregation, statistical calculations (mean, standard deviation), and gap-filling for missing dates
- **Anomaly Detection**: Use statistical methods (standard deviation thresholds) for identifying outliers in failure rates and latency patterns
- **Predictive Analytics**: Implement simple linear regression for trend prediction with confidence scoring based on slope magnitude
- **Quality Insights**: Generate automated insights by analyzing agent performance patterns and failure rate thresholds
- **Frontend Analytics**: Create tabbed analytics interfaces with responsive charts using Recharts library, supporting multiple time ranges and real-time data refresh
- **Database Performance**: Use PostgreSQL percentile functions for latency analysis and efficient date-based grouping for trend queries

## 7. Git Commit Guidelines

- **Staging Files**: Always use `git add -A` to stage all files (including deletions and renames) rather than `git add .` which only adds files in the current directory
- **Concise Commit Messages**: Keep commit messages concise and under 50 characters for the title to avoid commit operation failures
- **Format**: Use format "Action: Brief description" (e.g., "Add: Analytics dashboard", "Fix: Database connection", "Update: Phase 4 completion")
- **Avoid Long Descriptions**: Detailed descriptions can cause git commit failures; keep them brief and focused
- **Use Present Tense**: Write commit messages in present tense (e.g., "Add feature" not "Added feature")

## 8. Configuration Modularization Patterns

**Configuration Management Approach:**
- **Centralized Configuration**: Use Pydantic BaseSettings for type-safe configuration management with environment variable support
- **Environment-Specific Files**: Separate configuration files for development, testing, production, and Docker environments
- **Security First**: Never commit sensitive data (passwords, API keys, secrets) to version control
- **Validation**: Configuration should fail fast with clear error messages on startup
- **Precedence Order**: Environment variables > configuration files > defaults
- **Backward Compatibility**: Maintain compatibility during configuration migration

**Configuration Categories:**
- **Database Settings**: Connection strings, pool configurations, migration settings
- **Service Discovery**: Inter-service URLs, ports, timeouts, health check intervals
- **Security Configuration**: JWT secrets, password policies, CORS settings, rate limiting
- **Network Settings**: Host bindings, port mappings, timeout configurations
- **Application Settings**: Feature flags, pagination limits, logging levels, agent parameters
- **External Services**: LLM API configurations, third-party service integrations

**Implementation Patterns Successfully Applied:**
- **Service Configuration Import**: All services now import configuration using `from config.settings import get_settings, get_service_settings, get_application_settings`
- **Timeout Centralization**: HTTP clients use `service_settings.service_timeout` instead of hardcoded values
- **Service URL Configuration**: All inter-service communication uses `service_settings.{service_name}_service_url`
- **Logging Configuration**: Services use `app_settings.log_level` and `app_settings.log_format` for consistent logging
- **Configuration Caching**: Use `@lru_cache()` decorator for performance optimization in configuration loading
- **Type Safety**: All configuration access is type-safe through Pydantic models with proper validation

## 9. Configuration Modularization Patterns (COMPLETED)

**Configuration Management Approach Successfully Implemented:**
- **Centralized Configuration**: Comprehensive Pydantic BaseSettings system with type-safe configuration management and environment variable support
- **Environment-Specific Files**: Separate configuration files for development, testing, production, and Docker environments with automatic loading
- **Security First**: Production-ready security validation with JWT secret key validation and environment-specific security settings
- **Validation**: Configuration fails fast with clear error messages on startup using Pydantic validators
- **Precedence Order**: Environment variables > configuration files > defaults with proper override handling
- **Backward Compatibility**: Maintained compatibility during configuration migration across all services

**Configuration Categories Successfully Implemented:**
- **Database Settings**: Connection strings, pool configurations (pool_size, max_overflow, pool_timeout, pool_recycle), migration settings
- **Service Discovery**: Inter-service URLs, ports, timeouts, health check intervals with centralized service communication
- **Security Configuration**: JWT secrets, password policies, CORS settings, rate limiting, admin user configuration
- **Network Settings**: Host bindings, port mappings, timeout configurations for all services
- **Application Settings**: Feature flags, pagination limits, logging levels, agent parameters, test execution settings
- **Frontend Configuration**: Separate JavaScript configuration system with environment detection and validation
- **Agent Configuration**: Data mocking settings, security testing parameters, performance testing configurations

**Implementation Patterns Successfully Applied:**
- **Service Configuration Import**: All services now import configuration using `from config.settings import get_settings, get_service_settings, get_application_settings`
- **Timeout Centralization**: HTTP clients use `service_settings.service_timeout` instead of hardcoded values across all services
- **Service URL Configuration**: All inter-service communication uses `service_settings.{service_name}_service_url`
- **Logging Configuration**: Services use `app_settings.log_level` and `app_settings.log_format` for consistent logging
- **Security Settings**: Auth service uses `security_settings.jwt_secret_key`, `security_settings.cors_origins`, etc.
- **Configuration Caching**: Use `@lru_cache()` decorator for performance optimization in configuration loading
- **Type Safety**: All configuration access is type-safe through Pydantic models with proper validation
- **Frontend Integration**: Created comprehensive frontend configuration system with environment-specific overrides and utility functions
- **Agent Configuration**: Agents use `getattr(app_settings, 'setting_name', default_value)` pattern for configuration access

**Services Successfully Updated:**
- **auth_service**: Complete security configuration integration with JWT, CORS, admin user, and logging settings
- **execution_service**: Service URLs, timeouts, and logging configuration centralized
- **orchestration_service**: Service URLs, timeouts, and logging configuration centralized
- **auth_middleware**: Service URLs and timeout configuration centralized
- **CLI**: Default base URL and timeout configuration using centralized settings
- **Frontend**: Complete configuration system with API URLs, timeouts, and environment-specific settings

**Agents Successfully Updated:**
- **data_mocking_agent**: Mock data generation settings, faker locale, response/parameter/entity variations
- **security_auth_agent**: BOLA vectors, authentication scenarios, security test timeouts, aggressive testing mode
- **security_injection_agent**: Injection payload limits, timeout configurations, and security test parameters
- **performance_planner_agent**: Load test configurations, user limits, test duration, ramp-up times
- **functional_positive_agent**: Test execution timeouts and configuration-based test case generation
- **functional_negative_agent**: Test execution timeouts and configuration-based boundary value analysis
- **functional_stateful_agent**: Test execution timeouts and configuration-based stateful workflow testing

**Testing Infrastructure Successfully Implemented:**
- **pytest Configuration**: Comprehensive test configuration with markers, coverage, and environment settings
- **Test Fixtures**: Shared fixtures for database sessions, HTTP clients, LLM clients, and test data generation
- **Docker Test Environment**: Isolated test environment with separate ports and test database
- **Test Configuration Management**: Centralized test configuration with validation and utilities
- **Test Data Generation**: Comprehensive test data generators for all entity types and test scenarios

**Validation & Error Handling Successfully Implemented:**
- **Configuration Validation**: Comprehensive validation system with environment-specific rules and production security checks
- **Error Reporting**: Detailed error and warning reporting with categorization and clear messages
- **Configuration Management CLI**: Full-featured CLI tool for validation, backup, restore, migration, and template generation
- **Startup Validation**: Automatic configuration validation at application startup with fail-fast behavior

**Configuration Modularization Achievement:**
The configuration modularization initiative has been successfully completed across the entire Sentinel platform. All services and agents now use centralized, type-safe configuration management with environment-specific overrides, proper validation, and consistent patterns. Added comprehensive testing infrastructure and validation/error handling systems. This provides a solid foundation for production deployment and enterprise-grade configuration management. **Status: 90%+ Complete**

## 10. Open Source Licensing Patterns

**MIT License Implementation:**
- **License File**: Standard MIT License with project-specific copyright attribution
- **README Integration**: License section with clear reference to LICENSE file and contribution guidelines
- **Contribution Guidelines**: Standard GitHub contribution workflow with feature branches and pull requests
- **Open Source Positioning**: Clear messaging about open source nature and welcoming contributions

**License Content Standards:**
- Copyright year: Current year (2025)
- Copyright holder: "Sentinel API Testing Platform" (project name)
- Standard MIT License text without modifications
- Clear permissions and limitations outlined

## 11. Task Completion Protocol

**MANDATORY STEPS when completing any task:**

1. **Update Memory Bank**: Always update relevant memory bank files after completing a task:
   - Update `progress.md` to mark completed tasks and add implementation notes
   - Update `activeContext.md` to reflect current status and next steps
   - Update other relevant memory bank files if the task affects them

2. **Update README.md**: Always update the main README.md file to reflect:
   - New features or capabilities implemented
   - Changes to project structure or architecture
   - Updated phase completion status
   - New demo scripts or documentation

3. **Update .clinerules**: Document any new patterns, preferences, or implementation approaches discovered during the task

4. **Ask about GitHub Push**: At the end of every completed task, ask the user if all changes should be pushed to GitHub

## 12. Branch Management Protocol

**MANDATORY WORKFLOW for all tasks:**

1. **Create Task Branch**: Before starting any new task, create a new branch from main:
   - Branch naming convention: `task/brief-description` or `feature/brief-description`
   - Examples: `task/add-analytics-dashboard`, `feature/rbac-implementation`, `fix/database-connection`
   - Always branch from the latest main branch

2. **Work in Branch**: Perform all task-related work in the dedicated branch:
   - Make commits frequently with clear, descriptive messages following the Git Commit Guidelines
   - Keep commits focused and atomic - each commit should represent a logical unit of work
   - Test changes thoroughly before committing

3. **Complete Task in Branch**: When the task is complete:
   - Ensure all changes are committed to the task branch
   - Verify that all tests pass and the application works as expected
   - Update documentation and memory bank files as required by Task Completion Protocol

4. **Create Pull Request**: After task completion:
   - Push the task branch to the remote repository
   - Create a Pull Request (PR) from the task branch to main
   - Include a clear description of changes, testing performed, and any breaking changes
   - Reference any related issues or tasks in the PR description

5. **Branch Cleanup**: After PR is merged:
   - Delete the local task branch: `git branch -d task/branch-name`
   - Delete the remote task branch if not automatically cleaned up

**Branch Management Best Practices:**
- **Single Purpose**: Each branch should focus on a single task or feature
- **Short-Lived**: Keep branches short-lived to minimize merge conflicts
- **Regular Updates**: If working on long-running tasks, regularly rebase or merge from main
- **Clear Naming**: Use descriptive branch names that clearly indicate the task or feature
- **No Direct Main Commits**: Never commit directly to main - always use branches and PRs

## 13. Memory Bank Updates

-   The Memory Bank is the single source of truth. It MUST be updated after any significant architectural decision, feature implementation, or change in project direction.
-   `progress.md` should be updated at the end of every major work session to reflect the current state of the project.
-   `activeContext.md` should be reviewed and updated at the beginning of every work session to align on the immediate next steps.

## 14. Testing Protocol

**MANDATORY TESTING for all code and configuration changes:**

1.  **Identify Testing Strategy**: After implementing any change, identify and propose a testing strategy to validate the changes. This may include unit, integration, or end-to-end tests.
2.  **Run Existing Tests**: Always run the existing test suite to ensure no regressions have been introduced.
3.  **Implement New Tests**: Add new tests to cover the new functionality or configuration. For observability, this includes verifying log formats, metric exposure, and trace propagation.
4.  **Confirm Success**: Confirm that all tests (new and existing) pass before considering a task complete.

## 15. Documentation Structure

**Comprehensive Documentation Organization:**

The project maintains a structured documentation portal in the `/docs` directory with the following organization:

1. **User Guide** (`/docs/user-guide/`)
   - Quick Start Guide
   - API Specifications Management
   - Test Types and Strategies
   - CI/CD Integration
   - Web Interface Usage
   - Role-Based Access Control

2. **Technical Guide** (`/docs/technical-guide/`)
   - Architecture Overview
   - Service Components
   - Agent Implementation
   - Database Design
   - Configuration Management
   - Security Architecture
   - Observability Stack

3. **API Reference** (`/docs/api-reference/`)
   - Complete REST API documentation
   - Authentication and authorization
   - Request/response examples
   - Error codes and handling
   - SDK libraries usage

4. **Deployment Guide** (`/docs/deployment/`)
   - System requirements
   - Docker deployment
   - Kubernetes deployment
   - Cloud platform deployments
   - Production configuration
   - Scaling strategies

5. **Troubleshooting Guide** (`/docs/troubleshooting/`)
   - Common issues and solutions
   - Debugging techniques
   - Performance optimization
   - FAQ

**Documentation Standards:**
- All documentation must be in Markdown format
- Include code examples where applicable
- Maintain navigation links between related documents
- Update documentation when features change
- Include troubleshooting sections for complex topics

## 15. Frontend Architecture Patterns

- **State Management**: Use Redux Toolkit for centralized state management.
- **Data Fetching**: Use React Query for all asynchronous data fetching, caching, and synchronization.
- **BFF (Backend for Frontend)**: Implement BFF endpoints in the API Gateway to aggregate data from downstream services and simplify frontend logic.
- **Component Library**: Use a component-based approach with reusable components.
- **Styling**: Use Tailwind CSS for utility-first styling.

## 16. README.md Maintenance Patterns

**README.md Content Strategy:**
- **User-Focused**: README.md should focus on what users need to know to understand and use the platform
- **Production-Ready Presentation**: Present the platform as a polished, production-ready solution rather than work-in-progress
- **Essential Information Only**: Include architecture overview, quick start, key features, configuration, and documentation links
- **Phase Information Separation**: All phased implementation details, progress tracking, and development milestones belong in memory-bank files, not README.md

**Content to KEEP in README.md:**
- Project overview and value proposition
- Architecture overview (high-level)
- Core services and agents (brief descriptions)
- Quick start guide and prerequisites
- Multi-LLM provider support (key differentiator)
- Development setup instructions
- Configuration management (essential for users)
- Key features summary
- Authentication & RBAC (user-facing)
- License and contributing information
- Documentation portal links

**Content to REMOVE from README.md:**
- Detailed development phases and completion status
- Implementation-specific technical details
- Test coverage statistics and infrastructure details
- Recent platform enhancements with specific dates
- Phase-specific completion notes
- Internal development progress tracking

**Benefits of This Approach:**
- Creates a professional, user-focused first impression
- Reduces maintenance overhead (phases don't change frequently)
- Maintains clean separation between user documentation and development tracking
- Keeps README.md focused on getting users started quickly
