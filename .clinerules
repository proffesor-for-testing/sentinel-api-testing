# .clinerules for Sentinel Project

This file captures important patterns, preferences, and project intelligence to ensure consistent and effective development for the Sentinel platform.

## 1. Core Principles

- **Modularity:** All new features should be developed within the microservices-inspired architecture. Avoid adding unrelated functionality to existing services.
- **Agent Specialization:** When a new type of testing is required, the default approach should be to create a new, specialized agent rather than overloading an existing one.
- **Specification-Driven:** All development should be driven by the API specifications, both for the Sentinel platform's own internal APIs and for the APIs it is designed to test.
- **Hybrid AI:** Continue to leverage the hybrid approach of combining deterministic algorithms for rigor and LLMs for creativity and breadth.

## 2. Technology & Implementation Patterns

- **Python Backend:** All backend services will be written in Python 3.10+ using FastAPI.
- **Pydantic Models:** Use Pydantic for all data validation, settings management, and API request/response models. This ensures type safety and consistency.
- **Database Interaction:** Use an async ORM like `SQLAlchemy` with `asyncpg` for all interactions with the PostgreSQL database.
- **Dependency Injection:** Leverage FastAPI's dependency injection system for managing database sessions, service dependencies, and other resources.
- **Testing:** Use `pytest` for all backend unit and integration tests. The test suite for the platform itself should be comprehensive.

## 3. Agent Development Workflow

1.  **Define Specification:** Clearly define the agent's goal, inputs, and outputs in `agent-specifications.md`.
2.  **Develop Logic:** Implement the agent's core logic. If it involves interaction with `ruv-swarm`, ensure the commands are clearly defined.
3.  **Integrate with Orchestrator:** Add the new agent type to the Agent Orchestration Service's delegation logic.
4.  **Add to DB:** Ensure any new data generated by the agent is modeled correctly in the `database-schema.md` and corresponding ORM models.
5.  **Document:** Update all relevant Memory Bank files with the new agent's capabilities.

## 4. User Preferences & Workflow

- **CI/CD First:** The platform must be designed with CI/CD integration as a primary feature, not an afterthought. The API for triggering test runs should be stable and well-documented.
- **Actionable Feedback:** All user-facing outputs, from test results to linter reports, should provide clear, actionable feedback. Avoid vague error messages.
- **Transparency:** While the system is complex, its operations should be as transparent as possible. Logs should be detailed, and it should be clear why an agent made a particular decision.

## 5. RBAC Implementation Patterns

- **Authentication Service Architecture:** JWT-based authentication with bcrypt password hashing, role-based permissions, and in-memory user storage (easily replaceable with database)
- **Role Hierarchy:** Four-tier system (Admin > Manager > Tester > Viewer) with granular permissions for different platform features
- **Middleware Pattern:** Reusable authentication middleware with dependency injection for FastAPI services, supporting both required and optional authentication
- **Permission System:** Fine-grained permissions (e.g., "spec:create", "test_case:read") mapped to roles, enabling flexible access control
- **API Gateway Integration:** Centralized authentication through API Gateway with service-to-service token validation
- **Security Best Practices:** Secure token handling, password hashing, role-based endpoint protection, and comprehensive error handling

## 6. Task Completion Protocol

**MANDATORY STEPS when completing any task:**

1. **Update Memory Bank**: Always update relevant memory bank files after completing a task:
   - Update `progress.md` to mark completed tasks and add implementation notes
   - Update `activeContext.md` to reflect current status and next steps
   - Update other relevant memory bank files if the task affects them

2. **Update README.md**: Always update the main README.md file to reflect:
   - New features or capabilities implemented
   - Changes to project structure or architecture
   - Updated phase completion status
   - New demo scripts or documentation

3. **Update .clinerules**: Document any new patterns, preferences, or implementation approaches discovered during the task

4. **Ask about GitHub Push**: At the end of every completed task, ask the user if all changes should be pushed to GitHub

## 7. Memory Bank Updates

-   The Memory Bank is the single source of truth. It MUST be updated after any significant architectural decision, feature implementation, or change in project direction.
-   `progress.md` should be updated at the end of every major work session to reflect the current state of the project.
-   `activeContext.md` should be reviewed and updated at the beginning of every work session to align on the immediate next steps.
